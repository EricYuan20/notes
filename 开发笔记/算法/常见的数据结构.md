# 链表结构

## 单链表节点结构：

```java
 class Node {
	public int value;
	public Node next;

	public Node(int data) {
		value = data;
	}
}
```

## 双向链表节点结构：

```java
class DoubleNode {
    public int value;
    public DoubleNode last;
    public DoubleNode next;

    public DoubleNode(int data) {
        value = data;
    }
}
```

# 栈和队列

栈：数据先进后出，犹如弹匣；

队列：数据先进先出，好似排队。

## 栈和队列的实现：

### (1) 基于双向列表

自定义双向列表节点

```java
public static class Node<T>{
    public T value;
    public Node<T> last;
    public Node<T> next;
}
```

自定义双向链表

```java
public static class DoubleEndsQueue<T>{
   public Node<T> head;
   public Node<T> tail;
   //双向列表中从头部添加数据
   public void addFromHead(T value){
      Node<T> cur = new Node<T>(value);
      if (head==null){
         head=cur;
         tail=cur;
      }else {
         cur.next=head;
         head.last=cur;
         head=cur;
      }
   }
   //双向列表中从尾部添加数据
   public void addFromBottom(T value){
      Node<T> cur = new Node<T>(value);
      if (tail==null){
         head=cur;
         tail=cur;
      }else {
         cur.next=tail;
         tail.next=cur;
         tail=cur;
      }
   }
   //双向列表中从头部弹出数据
   public T popFromHead(){
      if (head==null){
         return null;
      }
      Node<T> cur=head;
      if (head==tail){
         head=null;
         tail=null;
      }else {
         head=cur.next;
         cur.next=null;
         head.last=null;
      }
      return cur.value;
   }
   //双向列表中从尾部弹出数据
   public T popFromBottom() {
      if (null == head) {
         return null;
      }
      T value=tail.value;
      if (head == tail) {
         head = null;
         tail = null;
      } else {
         tail = tail.last;
         tail.next = null;
      }
      return value;
   }

   public boolean isEmpty() {
      return null == head;
   }

}
```

**自定义栈**

```java
public static class MyStack<T>{
   private DoubleEndsQueue<T> queue;

   public MyStack(){
      queue=new DoubleEndsQueue<T>();
   }

   public void push(T value){
      queue.addFromHead(value);
   }

   public T pop(){
      return queue.popFromHead();
   }

   public boolean isEmpty(){
      return queue.isEmpty();
   }
}
```

**自定义队列**

```java
static class MyQueue<T> {
   private final DoubleEndsQueue<T> queue;

   public MyQueue() {
      queue = new DoubleEndsQueue<T>();
   }

   public void push(T value) {
      queue.addFromHead(value);
   }

   public T pop() {
      return queue.popFromBottom();
   }

   public boolean isEmpty() {
      return queue.isEmpty();
   }
}
```

### (2)基于数组实现

使用数组时，需要考虑数组的大小问题，这里选择使用固定长度的数组来实现

基于数组实现栈的话比较简单，使用index记录存储栈中数据的位置，从而跟据index判断push与pull的位置

```java
//基于数组实现的栈
public static class MyStack{
    private final int[] arr;
    private int index;
    private int limit;

    public MyStack(int limit) {
        arr = new int[limit];
        index = 0;
        this.limit=limit;
    }

    public void push(int num){
        if (index>=limit){
            throw new RuntimeException("栈已满，不能再添加元素！");
        }else {
            arr[index]=num;
            index++;
        }
    }

    public int pull(){
        if (index==0){
            throw new RuntimeException("栈已空，不能再弹出元素！");
        }else {
            return arr[--index];
        }
    }
}
```

数组实现队列时比较麻烦，需要使用环形数组的思想实现，即RingBuffer的原理，具体可参考

```java
static class Queue {
    private final int[] arr;
    private int pushi;          // 加元素的下标
    private int pulli;          // 取元素的下标
    private int size;
    private final int limit;    // 队列大小

    public Queue(int limit) {
        arr = new int[limit];
        pushi = 0;
        pulli = 0;
        size = 0;
        this.limit = limit;
    }

    public void push(int num) {
        if (size == limit) {
            throw new RuntimeException("队列已满，不能再添加元素！");
        }
        size++;
        arr[pushi] = num;
        pushi = nextIndex(pushi);
    }

    public int pull() {
        if (isEmpty()) {
            throw new RuntimeException("队列已空，不能再取元素！");
        }
        size--;
        int res = arr[pulli];
        pulli = nextIndex(pulli);
        return res;
    }

    public boolean isEmpty() {
        return 0 == size;
    }

    private int nextIndex(int index) {
        return index < (limit - 1) ? (index + 1) : 0;
    }
}
```

## 用队列实现栈

用两个队列来实现，包括原始队列和辅助队列，如下：

两个队列角色互相切换。

```java
static class TwoQueueStack<T> {

    private Queue<T> queue;
    private Queue<T> help;

    public TwoQueueStack() {
        queue = new LinkedList<>();
        help = new LinkedList<>();
    }

    public void push(T value) {
        queue.offer(value);
    }

    public T pop() {
        while (queue.size() > 1) {
            help.offer(queue.poll());
        }
        T res = queue.poll();
        Queue<T> tmp = queue;
        queue = help;
        help = tmp;
        return res;
    }

    public T peek() {
        while (queue.size() > 1) {
            help.offer(queue.poll());
        }
        T res = queue.poll();
        help.offer(res);
        Queue<T> tmp = queue;
        queue = help;
        help = tmp;
        return res;
    }

    public boolean isEmpty() {
        return queue.isEmpty();
    }
}
```

## 用栈实现队列

也是用两个栈来实现，包括push栈和pop栈，push栈用于加入数据、pop用于弹出数据，

遵循的原则：

pop栈为空时，才能将数据导入到pop栈中；
push栈导数据到pop栈时，一次导完。

```java
static class TwoStackQueue {
    private final Stack<Integer> stackPush;
    private final Stack<Integer> stackPop;

    public TwoStackQueue() {
        stackPush = new Stack<Integer>();
        stackPop = new Stack<Integer>();
    }

    // push栈向pop栈导入数据
    private void pushToPop() {
        if (stackPop.isEmpty()) {
            while (!stackPush.isEmpty()) {
                stackPop.push(stackPush.pop());
            }
        }
    }
    
    public void add(int num) {
        stackPush.push(num);
        pushToPop();
    }
    
    public int poll() {
        if (stackPush.isEmpty() && stackPop.isEmpty()) {
            throw new RuntimeException("Queue is empty!");
        }
        pushToPop();
        return stackPop.pop();
    }
    
    public int peek() {
        if (stackPush.isEmpty() && stackPop.isEmpty()) {
            throw new RuntimeException("Queue is empty!");
        }
        pushToPop();
        return stackPop.peek();
    }
}
```

